% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/mixedsde.fit.R
\name{mixedsde.fit}
\alias{mixedsde.fit}
\title{Estimation Of The Random Effects In Mixed Stochastic Differential Equations}
\usage{
mixedsde.fit(times, X, model = c("OU", "CIR"), random, fixed = 0,
  estim.method = c("nonparam", "paramML", "paramBayes"), gridf = NULL,
  prior, nMCMC = NULL)
}
\arguments{
\item{times}{vector of observation times}

\item{X}{matrix of the M trajectories (each row is a trajectory with as much columns as observations)}

\item{model}{name of the SDE: 'OU' (Ornstein-Uhlenbeck) or 'CIR' (Cox-Ingersoll-Ross)}

\item{random}{random effects in the drift: 1 if one additive random effect, 2 if one multiplicative random effect or c(1,2) if 2 random effects}

\item{fixed}{fixed effect in the drift: value of the fixed effect when there is only one random effect, 0 otherwise}

\item{estim.method}{estimation method: 'paramML' for a Gaussian parametric estimation by maximum likelihood, 'paramBayes' for a Gaussian parametric Bayesian estimation or 'nonparam' for a non-parametric estimation}

\item{gridf}{if nonparametric estimation: grid of values on which the density is estimated, a matrix with two rows if two random effects; NULL by default and
then grid is chosen as a function of the estimated values of the random effects. For the plots this grid is used.}

\item{prior}{if method = 'paramBayes', list of prior parameters: mean and variance of the Gaussian prior on the mean mu, shape and scale of the inverse Gamma prior for the variances omega, shape and scale of the inverse Gamma prior for sigma}

\item{nMCMC}{if method = 'paramBayes', number of iterations of the MCMC algorithm}
}
\value{
\item{index}{is the vector of subscript in \eqn{1,...,M} where the estimation of \eqn{phi} has been done,  most of the time \eqn{index= 1:M}}
\item{estimphi}{matrix of estimators of \eqn{\phi=\alpha, or \beta, or (\alpha,\beta)} from the efficient statitics (see \code{\link{UV}}), matrix of two lines if random =c(1,2), numerical type otherwise}
\item{gridf}{grid of values on which the estimated is done for the nonparametric method, otherwise, grid used for the plots, matrix form}
\item{estimf}{estimator of the density of \eqn{\phi} from a kernel estimator from package: stats, function: density, or package: MASS, function: kde2D. Matrix form: one line if one random effect or square matrix otherwise}
If there is a truncation threshold in the estimator
\item{cutoff}{the binary vector of cutoff, FALSE otherwise}
\item{estimphi_trunc}{troncated estimator of \eqn{\phi}, vector or matrix of 0 if we do not use truncation, matrix of two lines if random =c(1,2), numerical type otherwise}
\item{estimf_trunc}{troncated estimator of the density of \eqn{\phi}, vector or matrix of 0 if we do not use truncation, matrix if random =c(1,2), numerical type otherwise}
For the parametric maximum likelihood estimation
\item{mu}{estimator of the mean of the random effects normal density, 0 if we do nonparametric estimation}
\item{omega}{estimator of the standard deviation of the random effects normal density, 0 if we do nonparametric estimation}
\item{bic}{BIC criterium, 0 if we do nonparametric estimation}
\item{aic}{AIC criterium, 0 if we do nonparametric estimation}
\item{model}{initial choice}
\item{random}{initial choice}
\item{fixed}{initial choice}

For the parametric Bayesian estimation
\item{alpha}{posterior samples (Markov chain) of \eqn{\alpha}}
\item{beta}{posterior samples (Markov chain) of \eqn{\beta}}
\item{mu}{posterior samples (Markov chain) of \eqn{\mu}}
\item{omega}{posterior samples (Markov chain) of \eqn{\Omega}}
\item{sigma2}{posterior samples (Markov chain) of \eqn{\sigma^2}}
\item{model}{initial choice}
\item{random}{initial choice}
\item{burnIn}{proposal for burn-in period}
\item{thinning}{proposal for thinning rate}
\item{prior}{initial choice or calculated by the first 10\% of series}
\item{times}{initial choice}
\item{X}{initial choice}
\item{ind.4.prior}{in the case of calculation of prior parameters: the indices of used series}
}
\description{
Estimation of the random effects \eqn{(\alpha_j, \beta_j)} and of their density, parametrically or nonparametrically in the mixed SDE
 \eqn{dX_j(t)= (\alpha_j- \beta_j X_j(t))dt + \sigma a(X_j(t)) dW_j(t)}.
}
\details{
Estimation of the random effects density from M independent trajectories of the SDE (the Brownian motions \eqn{Wj} are independent), with linear drift. Two diffusions are implemented, with one or two random effects:
\subsection{Ornstein-Uhlenbeck model (OU)}{
If random = 1, \eqn{\beta} is a fixed effect: \eqn{dX_j(t)= (\alpha_j- \beta X_j(t))dt + \sigma dW_j(t)  }

If random = 2, \eqn{\alpha} is a fixed effect: \eqn{dX_j(t)= (\alpha - \beta_j X_j(t))dt + \sigma dW_j(t)  }

If random = c(1,2), \eqn{dX_j(t)= (\alpha_j- \beta_j X_j(t))dt + \sigma dW_j(t)  }
}
\subsection{Cox-Ingersoll-Ross model (CIR)}{
If random = 1, \eqn{\beta} is a fixed effect: \eqn{dX_j(t)= (\alpha_j- \beta X_j(t))dt + \sigma \sqrt{X_(t)} dWj_(t)  }

If random = 2, \eqn{\alpha} is a fixed effect: \eqn{dX_j(t)= (\alpha - \beta_j X_j(t))dt + \sigma \sqrt{X_j(t)} dW_j(t)  }

If random = c(1,2), \eqn{dXj(t)= (\alpha_j- \beta_j Xj(t))dt + \sigma \sqrt{Xj(t)}  dWj(t)  }
}
The nonparametric method estimates the density of the random effects with a kernel estimator (one-dimensional or two-dimensional density).
The parametric method estimates the mean and standard deviation of the Gaussian distribution of the random effects.
}
\examples{
#Choices
model = 'CIR'; M <- 200;  T <- 10 ; delta <- 0.001; N <- floor(T/delta); sigma <- 0.01 ; random <- c(1,2); density.phi <- 'gammainvgamma2';
param<- c(1.8, 0.8, 8, 0.05);
simu <- mixedsde.sim(M=M,T=T,N=N,model=model,random=random,density.phi=density.phi,param=param,sigma=sigma, invariant = 1)
X <- simu$X ; phi <- simu$phi; times <- simu$times
estim.method<- 'nonparam'
estim <- mixedsde.fit(times=times, X=X, model=model, random=random, estim.method= 'nonparam')
#To stock the results of the function \\code{mixedsde.fit}, use method \\code{out}
#which put the outputs of the function on a list according to the frequentist or Bayesian approach.
outputsNP <- out(estim)
plot(estim)
# It represents the bidimensional density, the histogram of the first estimated random effect \\eqn{\\alpha} with the
# marginal of \\eqn{\\hat{f}} from the first coordonate which estimates the density of \\eqn{\\alpha}. And the same for the
# second random effect \\eqn{\\beta}. More, it plots a qq-plot for the sample of estimator of the random effects
# compared with the quantiles of a Gaussian sample with the same mean and standard deviation.

summary(estim)
print(estim)
# Validation
# If numj is fixed by the user: this function simulates Mrep =100 (by default) new trajectories with the value of the
#estimated random effect. Then it plots on the left graph the Mrep new trajectories \\eqn{(Xnumj^{k}(t1), ... Xnumj^{k}(tN)), k= 1, ... Mrep}
#with in red the true trajectory \\eqn{(Xnumj(t1), ... Xnumj(tN))}.
#The right graph is a qq-plot of the quantiles of samples \\eqn{(Xnumj^{1}(ti), ... Xnumj^{Mrep}(ti))}
#for each time \\eqn{ti} compared with the uniform quantiles. The outputs of the function are: a matrix \\code{Xnew} dimension Mrepx N+1, vector
#of quantiles \\code{quantiles} length N and the number of the trajectory for the plot \\code{plotnumj= numj}
# If numj is not precised by the user, then, this function simulates Mrep =100 (by default) new trajectories for each estimated
#random effect. Then left graph is a plot of the Mrep new trajectories \\eqn{(Xj^{k}(t1), ... Xj^{k}(tN)), k= 1, ... Mrep}
#for a randomly chosen number j with in red the true trajectory \\eqn{(Xj(t1), ... Xj(tN))}.
#The right graph is a qq-plot of the quantiles of samples \\eqn{(Xj^{1}(ti), ... Xj^{Mrep}(ti))}, for the same j and
#for each time \\eqn{ti}. The outputs of the function are: a list of matrices \\code{Xnew} length M, matrix of quantiles \\code{quantiles} dimension MxN and the
#number of the trajectory for the plot \\code{plotnumj}

validation <- valid(estim, X, times=times,  numj=floor(runif(1,1,M)))

# Parametric estimation
estim.method<-'paramML'
estim_param <- mixedsde.fit(times= times, X= X, model= model, random= random, estim.method = 'paramML')
outputsP <- out(estim_param)
plot(estim_param)
summary(estim_param)

# Prediction for the frequentist approach
# This function uses the estimation of the density function to simulate a new sample of random
# effects according to this density. If \\code{plot.pred =1} (default) is plots on the top
# the predictive random effects versus the estimated random effects from the data.
# On the bottom, the left graph is the true trajectories, on the right the predictive trajectories
# and the empiric prediciton intervals at level \\code{level=0.05} (defaut).
# The function return on a list the prediction of phi \\code{phipred}, the prediction of X \\code{Xpred},
# and the indexes of the corresponding true trajectories \\code{indexpred}

test1 <- pred(estim, X,  estim.method= 'nonparam', times=times)
test2 <- pred(estim_param,  X,  estim.method= 'paramML', times=times)

# More graph
fhat <- outputsNP$estimf
fhat_trunc <- outputsNP$estimf_trunc
fhat_param <- outputsP$estimf

gridf <- outputsNP$gridf; gridf1 <- gridf[1,]; gridf2 <- gridf[2,]

marg1 <- ((max(gridf2)-min(gridf2))/length(gridf2))*apply(fhat,1,sum)
marg1_trunc <- ((max(gridf2)-min(gridf2))/length(gridf2))*apply(fhat_trunc,1,sum)
marg2 <- ((max(gridf1)-min(gridf1))/length(gridf1))*apply(fhat,2,sum)
marg2_trunc <- ((max(gridf1)-min(gridf1))/length(gridf1))*apply(fhat_trunc,2,sum)

marg1_param <- ((max(gridf2)-min(gridf2))/length(gridf2))*apply(fhat_param,1,sum)
marg2_param <- ((max(gridf1)-min(gridf1))/length(gridf1))*apply(fhat_param,2,sum)
f1 <-  (gridf1^(param[1]-1))*exp(-gridf1/param[2])/((param[2])^param[1]*gamma(param[1]))
f2 <-  (gridf2^(-param[3]-1))*exp(-(1/param[4])*(1/gridf2))*((1/param[4])^param[3])*(1/gamma(param[3]))
par(mfrow=c(1,2))
plot(gridf1,f1,type='l', lwd=1,  xlab='', ylab='')
lines(gridf1,marg1_trunc,col='blue', lwd=2)
lines(gridf1,marg1,col='blue', lwd=2, lty=2)
lines(gridf1,marg1_param,col='red', lwd=2, lty=2)
plot(gridf2,f2,type='l', lwd=1, xlab='', ylab='')
lines(gridf2,marg2_trunc,col='blue', lwd=2)
lines(gridf2,marg2,col='blue', lwd=2, lty=2)
lines(gridf2,marg2_param,col='red', lwd=2, lty=2)

cutoff <- outputsNP$cutoff
phihat <- outputsNP$estimphi
phihat_trunc <- outputsNP$estimphi_trunc
par(mfrow=c(1,2))
plot.ts(phi[1,], phihat[1,], xlim=c(0, 15), ylim=c(0,15), pch=18); abline(0,1)
points(phi[1,]*(1-cutoff), phihat[1,]*(1-cutoff), xlim=c(0, 20), ylim=c(0,20),pch=18, col='red'); abline(0,1)
plot.ts(phi[2,], phihat[2,], xlim=c(0, 15), ylim=c(0,15),pch=18); abline(0,1)
points(phi[2,]*(1-cutoff), phihat[2,]*(1-cutoff), xlim=c(0, 20), ylim=c(0,20),pch=18, col='red'); abline(0,1)


# Parametric Bayesian estimation
# one random effect
model <- 'OU'; random <- 1; sigma <- 0.1; fixed <- 5
M <- 50 ; T <- 1; N <- 100; param <- c(3, 0.5)

simu <- mixedsde.sim(M, T = T, N = N, model, random, fixed = fixed, density.phi = 'normal', param, sigma, X0 = 0, op.plot = 0)
X <- simu$X; phi <- simu$phi; times <- simu$times
plot(times, X[1,], ylim = range(X), type='l'); for(i in 2:M) lines(times, X[i,])

estim_Bayes_withoutprior <- mixedsde.fit(times, X, model, random, estim.method = 'paramBayes', nMCMC = 1000)
plot(estim_Bayes_withoutprior)

prior <- list( m = c(param[1], fixed), v = c(param[1], fixed), alpha.omega = 11, beta.omega = param[2]^2*10,
alpha.sigma = 10, beta.sigma = sigma^2*9)
estim_Bayes <- mixedsde.fit(times, X, model, random, estim.method = 'paramBayes', prior = prior, nMCMC = 1000)

validation <- valid(estim_Bayes, numj = 10)
plot(estim_Bayes)
outputBayes <- out(estim_Bayes)
summary(outputBayes)
(results_Bayes <- summary(estim_Bayes))
plot(estim_Bayes, style = 'cred.int', true.phi = phi)
plot(estim_Bayes_withoutprior, style = 'cred.int', true.phi = phi, reduced = TRUE)

plot.compare(estim_Bayes, estim_Bayes_withoutprior, names=c("with prior", "without prior"))

print(estim_Bayes)

pred.result <- pred(estim_Bayes)
summary(out(pred.result))
plot(pred.result)

pred.result.trajectories <- pred(estim_Bayes, trajectories = TRUE)

# second example

model <- 'CIR'; random <- 2; sigma <- 0.2; fixed <- 5
M <- 20 ; T <- 1; N <- 100; param <- c(3, 0.5)

simu <- mixedsde.sim(M, T = T, N = N, model, random, fixed = fixed, density.phi = 'normal', param, sigma, X0 = 0.1, op.plot = 0)
X <- simu$X; phi <- simu$phi; times <- simu$times
plot(times, X[1,], ylim = range(X), type='l'); for(i in 2:M) lines(times, X[i,])

prior <- list( m = c(fixed, param[1]), v = c(fixed, param[1]), alpha.omega = 11, beta.omega = param[2]^2*10,
alpha.sigma = 10, beta.sigma = sigma^2*9)

estim_Bayes <- mixedsde.fit(times, X, model, random, estim.method = 'paramBayes', prior = prior, nMCMC = 1000)
plot(estim_Bayes)
outputBayes <- out(estim_Bayes)
summary(outputBayes)
(results_Bayes <- summary(estim_Bayes))
plot(estim_Bayes, style = 'cred.int', true.phi = phi, reduced = TRUE)

print(estim_Bayes)
pred.result <- pred(estim_Bayes)
summary(out(pred.result))
plot(pred.result)

# for two random effects
model <- 'OU'; random <- c(1, 2); sigma <- 0.1
M <- 20 ; T <- 1; N <- 100; param <- c(3, 0.5, 5, 0.2)

simu <- mixedsde.sim(M, T = T, N = N, model, random, density.phi = 'normalnormal', param = param, sigma = sigma, X0 = 0, op.plot = 0)
X <- simu$X; phi <- simu$phi; times <- simu$times
plot(times, X[1,], ylim = range(X), type='l'); for(i in 2:M) lines(times, X[i,])

estim_Bayes_withoutprior <- mixedsde.fit(times, X, model, random, estim.method = 'paramBayes', nMCMC = 1000)
plot(estim_Bayes_withoutprior, style = 'cred.int', true.phi = phi, reduced = TRUE)

prior <- list( m = param[c(1, 3)], v = param[c(1, 3)], alpha.omega = c(11, 11), beta.omega = param[c(2, 4)]^2*10,
alpha.sigma = 10, beta.sigma = sigma^2*9)

estim_Bayes <- mixedsde.fit(times, X, model, random, estim.method = 'paramBayes', prior = prior, nMCMC = 1000)
outputBayes <- out(estim_Bayes)
summary(outputBayes)
summary(estim_Bayes)
plot(estim_Bayes)
plot(estim_Bayes, style = 'cred.int', true.phi = phi)
print(estim_Bayes)

pred.result <- pred(estim_Bayes)

# for Virkler data
data("crack.data")
X <- crack.data[[1]]
times <- crack.data[[2]]

estim_Bayes_Virkler1 <- mixedsde.fit(times, X, model = "OU", random = 1, estim.method = 'paramBayes', nMCMC = 2000)
estim_Bayes_Virkler2 <- mixedsde.fit(times, X, model = "OU", random = 2, estim.method = 'paramBayes', nMCMC = 2000)
estim_Bayes_Virkler12 <- mixedsde.fit(times, X, model = "OU", random = c(1, 2), estim.method = 'paramBayes', nMCMC = 2000)

plot(estim_Bayes_Virkler1)
plot(estim_Bayes_Virkler2, reduced = TRUE, plot.priorMean = FALSE)
plot(estim_Bayes_Virkler12, reduced = TRUE, style = "density", plot.priorMean = FALSE)
plot.compare(estim_Bayes_Virkler1, estim_Bayes_Virkler2, estim_Bayes_Virkler12, names = c("random=1", "random=2", "random=(1,2)"))

pred.result1 <- pred(estim_Bayes_Virkler1)
pred.result2 <- pred(estim_Bayes_Virkler2)
pred.result12 <- pred(estim_Bayes_Virkler12)

plot.compare(pred.result1, pred.result2, pred.result12, names = c("random=1", "random=2", "random=(1,2)"))

pred.result1_traj <- pred(estim_Bayes_Virkler1, trajectories = TRUE)
pred.result2_traj <- pred(estim_Bayes_Virkler2, trajectories = TRUE)
pred.result12_traj <- pred(estim_Bayes_Virkler12, trajectories = TRUE)

plot.compare(pred.result1_traj, pred.result2_traj, pred.result12_traj, names = c("random=1", "random=2", "random=(1,2)"))
}
\references{
For the parametric estimation see:
Maximum likelihood estimation for stochastic differential equations with random effects, M. Delattre, V. Genon-Catalot and A. Samson, \emph{Scandinavian Journal of Statistics 2012}, Vol 40, \bold{322--343}

For the nonparametric estimation see:

Nonparametric estimation for stochastic differential equations with random effects, F. Comte, V. Genon-Catalot and A. Samson, \emph{Stochastic Processes and Their Applications 2013}, Vol 7, \bold{2522--2551}

Estimation for stochastic differential equations with mixed effects, V. Genon-Catalot and C. LarÃ©do 2014 \emph{e-print: hal-00807258 }

Bidimensional random effect estimation in mixed stochastic differential model, C. Dion and V. Genon-Catalot,  \emph{Stochastic Inference for Stochastic Processes 2015, Springer Netherlands}, \bold{1--28}
}
\keyword{estimation}

